<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Pixel Quest: Island of Shadows</title>
<style>
  /* Mobile-first styling */
  :root{
    --ui-bg:#0b1020;
    --ui-fg:#e6eef8;
    --accent:#ffcc33;
    --muted:#9fb0c8;
    --hud-bg: rgba(0,0,0,0.5);
  }
  html,body{height:100%;margin:0;background:linear-gradient(#0b1220,#06121a);color:var(--ui-fg);font-family:monospace,-apple-system,system-ui,Segoe UI;}
  #gameWrap{display:flex;flex-direction:column;min-height:100vh;align-items:center;justify-content:center;padding:6px;box-sizing:border-box;}
  canvas{image-rendering:pixelated;background:#08202a;border:4px solid #000;border-radius:8px;touch-action:none;}
  /* HUD / UI overlay */
  .hud{position:fixed;left:6px;right:6px;top:6px;display:flex;justify-content:space-between;align-items:center;pointer-events:none;z-index:30}
  .hud .left,.hud .right{display:flex;gap:8px;align-items:center;pointer-events:auto}
  .panel{background:var(--hud-bg);padding:6px 8px;border-radius:8px;color:var(--ui-fg);font-size:14px;backdrop-filter:blur(3px);border:1px solid rgba(255,255,255,0.05)}
  .bigStat{font-weight:700;font-size:16px}
  #potionBtn{width:40px;height:40px;border-radius:6px;background:linear-gradient(#6a2,#4a8);display:flex;align-items:center;justify-content:center;cursor:pointer}
  #potionBtn.disabled{opacity:0.35;pointer-events:none}
  /* Control area (bottom) */
  .controls{position:fixed;left:0;right:0;bottom:6px;display:flex;justify-content:space-between;align-items:end;padding:12px;pointer-events:none;z-index:40}
  /* joystick container */
  #joyWrap{width:140px;height:140px;margin-left:8px;pointer-events:auto;display:flex;align-items:center;justify-content:center}
  #joystick{width:120px;height:120px;border-radius:999px;background:linear-gradient(180deg,#0b2430,#04202e);box-shadow:inset 0 2px 0 rgba(255,255,255,0.03);position:relative;touch-action:none}
  #joyStickThumb{position:absolute;width:46px;height:46px;background:linear-gradient(#ffd,#ff9);border-radius:8px;left:37px;top:37px;transform:translate(0,0);box-shadow:0 3px 0 rgba(0,0,0,0.6)}
  /* action button */
  #actionBtn{width:88px;height:88px;border-radius:999px;background:linear-gradient(180deg,#ff6b6b,#c43b3b);display:flex;align-items:center;justify-content:center;font-weight:900;font-size:20px;pointer-events:auto;margin-right:8px;box-shadow:0 6px 0 rgba(0,0,0,0.5);border:3px solid rgba(255,255,255,0.06)}
  /* menus and overlays */
  .overlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:linear-gradient(rgba(0,0,0,0.6),rgba(0,0,0,0.65));z-index:100}
  .menu{background:#05121b;padding:18px;border-radius:12px;min-width:260px;border:2px solid rgba(255,255,255,0.04);text-align:center}
  .menu h1{margin:0 0 8px 0;font-size:20px}
  .menu button{margin-top:10px;padding:10px 12px;border-radius:8px;background:var(--accent);border:none;font-weight:700;cursor:pointer}
  .small{font-size:13px;color:var(--muted);margin-top:6px}
  /* dialog box */
  #dialog{position:fixed;left:50%;bottom:110px;transform:translateX(-50%);min-width:220px;max-width:90vw;background:rgba(0,0,0,0.6);padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);z-index:60;display:none}
  #dialog p{margin:0;color:var(--ui-fg);font-size:14px}
  /* responsive adjustments for desktop testing */
  @media(min-width:700px){
    #gameWrap{padding:20px}
    canvas{width:720px;height:480px}
    #joystick{width:140px;height:140px}
    #joyStickThumb{width:56px;height:56px;left:42px;top:42px}
    #actionBtn{width:100px;height:100px;font-size:22px}
  }
</style>
</head>
<body>
<div id="gameWrap">
  <!-- Canvas: pixel-art rendering -->
  <canvas id="game" width="320" height="192"></canvas>
</div>

<!-- HUD -->
<div class="hud">
  <div class="left">
    <div class="panel" id="statsPanel">
      <div>HP <span id="hpText" class="bigStat">10/10</span></div>
      <div>XP <span id="xpText">0</span> ‚Ä¢ Lvl <span id="lvlText">1</span></div>
    </div>
  </div>
  <div class="right">
    <div class="panel">Coins: <span id="coinText">0</span></div>
    <div class="panel" style="display:flex;align-items:center;gap:8px">
      <div id="potionBtn" title="Use potion (heals)">üçæ<span id="potionCount" style="margin-left:6px;font-weight:700">0</span></div>
    </div>
  </div>
</div>

<!-- Dialog -->
<div id="dialog"><p id="dialogText"></p></div>

<!-- Controls -->
<div class="controls">
  <div id="joyWrap">
    <div id="joystick">
      <div id="joyStickThumb"></div>
    </div>
  </div>
  <div id="actionBtn">A</div>
</div>

<!-- Menus -->
<div id="startMenu" class="overlay">
  <div class="menu">
    <h1>Pixel Quest: Island of Shadows</h1>
    <div class="small">Mobile-first pixel RPG ‚Ä¢ Defeat the slimes and help the villager</div>
    <button id="startBtn">Start New Game</button>
    <button id="loadBtn">Load Save</button>
    <div style="margin-top:12px"><button id="creditsBtn" style="background:#2b2b2b;color:var(--ui-fg)">Credits</button></div>
  </div>
</div>

<div id="pauseMenu" class="overlay" style="display:none">
  <div class="menu">
    <h1>Paused</h1>
    <div class="small" id="questSummary">Quest: ‚Äî</div>
    <button id="resumeBtn">Resume</button>
    <button id="saveBtn" style="background:#2b2b2b;color:var(--ui-fg)">Save Game</button>
    <button id="restartBtn" style="background:#922">Restart</button>
  </div>
</div>

<div id="gameOverMenu" class="overlay" style="display:none">
  <div class="menu">
    <h1>Game Over</h1>
    <div id="gameOverMsg" class="small">You have fallen...</div>
    <button id="respawnBtn">Respawn (keep coins)</button>
    <button id="goToMenuBtn" style="background:#2b2b2b;color:var(--ui-fg)">Main Menu</button>
  </div>
</div>

<script>
/*
  Pixel Quest: Island of Shadows
  Single-file mobile-first pixel-art mini-RPG.

  Key adjustable variables (search for "CONFIG"):
    - TILE_SIZE: pixel size of tiles in canvas pixels (small to keep performance)
    - MAP_W, MAP_H: map grid size
    - SLIME_COUNT: initial number of slimes to spawn
    - XP_PER_SLIME, COIN_PER_SLIME: rewards
    - XP_TO_LEVEL: base XP formula
    - PLAYER_BASE_ATTACK, PLAYER_BASE_HP: starting stats
    - POTION_HEAL and starting potions
*/

/* =========================
   CONFIG / TUNABLE VALUES
   ========================= */
const CONFIG = {
  TILE_SIZE: 24,            // tile size in canvas pixels (increase for larger sprites)
  MAP_W: 64,                // map width in tiles
  MAP_H: 48,                // map height in tiles
  SLIME_COUNT: 12,           // starting slimes on map
  XP_PER_SLIME: 6,
  COIN_PER_SLIME: 3,
  XP_BASE: 8,               // base XP needed for level 2 (scales)
  PLAYER_BASE_ATTACK: 4,
  PLAYER_BASE_HP: 24,
  POTION_HEAL: 8,
  STARTING_POTIONS: 3,
  PLAYER_SPEED: 100,         // pixels per second
  ENEMY_SPEED: 28,
  ATTACK_COOLDOWN: 400,     // ms
  ENEMY_CONTACT_DAMAGE: 2,
  DAMAGE_COOLDOWN: 800      // ms invulnerability after hit
};

/* =========================
   SETUP CANVAS & SCALING
   ========================= */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
// We'll render at logical resolution of width x height (set in HTML attributes).
const W = canvas.width, H = canvas.height;
// Scale up canvas visually but we keep internal resolution fixed for pixels.
// For mobile, we'll fit canvas to viewport width while preserving aspect ratio.
function fitCanvas(){
  const maxW = Math.min(window.innerWidth - 12, 960);
  const scale = Math.floor(maxW / W) || 1;
  canvas.style.width = (W * scale) + 'px';
  canvas.style.height = (H * scale) + 'px';
}
window.addEventListener('resize', fitCanvas);
fitCanvas();

/* =========================
   Utility helpers
   ========================= */
function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }

/* =========================
   SIMPLE WEB AUDIO (beeps)
   ========================= */
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function beep(freq=440,dur=0.08, type='sine', vol=0.12){
  const now = audioCtx.currentTime;
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = type; o.frequency.setValueAtTime(freq, now);
  g.gain.setValueAtTime(vol, now);
  o.connect(g); g.connect(audioCtx.destination);
  o.start(now); o.stop(now+dur);
}

/* =========================
   Tile map generation
   =========================
   0 = grass, 1 = water, 2 = wall/blocked, 3 = sand (decor)
   We'll procedurally make an island in a sea.
*/
const MAP_W = CONFIG.MAP_W, MAP_H = CONFIG.MAP_H;
const TILE = { GRASS:0, WATER:1, WALL:2, SAND:3 };
let map = new Array(MAP_W*MAP_H).fill(TILE.GRASS);
function mapIndex(x,y){ return y*MAP_W+x; }

function generateMap(){
  // Fill water and carve an island using noise-ish circles
  for(let y=0;y<MAP_H;y++) for(let x=0;x<MAP_W;x++) map[mapIndex(x,y)]=TILE.WATER;
  // center island
  const cx = Math.floor(MAP_W/2), cy = Math.floor(MAP_H/2);
  const maxR = Math.min(MAP_W,MAP_H)/2 - 2;
  for(let i=0;i<6;i++){
    const r = maxR * (0.5 + Math.random()*0.7) * (i===0?1:0.6);
    const offx = (Math.random()-0.5)*4;
    const offy = (Math.random()-0.5)*3;
    for(let y=0;y<MAP_H;y++) for(let x=0;x<MAP_W;x++){
      const dx = x - (cx + offx);
      const dy = y - (cy + offy);
      const d = Math.hypot(dx,dy);
      if(d<r + (Math.random()*1.8-0.9)){
        map[mapIndex(x,y)] = TILE.GRASS;
      }
    }
  }
  // add sand ring and walls
  for(let y=1;y<MAP_H-1;y++) for(let x=1;x<MAP_W-1;x++){
    if(map[mapIndex(x,y)]===TILE.GRASS){
      // if near water -> sand
      if([ [0,-1],[1,0],[0,1],[-1,0] ].some(([dx,dy])=>map[mapIndex(x+dx,y+dy)]===TILE.WATER)){
        map[mapIndex(x,y)] = TILE.SAND;
      }
    }
  }
  // Scatter a few rocks (walls) on grass
  for(let i=0;i<30;i++){
    let rx = randInt(2,MAP_W-3), ry = randInt(2,MAP_H-3);
    if(map[mapIndex(rx,ry)]===TILE.GRASS) map[mapIndex(rx,ry)] = TILE.WALL;
  }
}
generateMap();

/* =========================
   ENTITIES: player, NPC, enemies
   ========================= */
const state = {
  player: {
    x: Math.floor(MAP_W/2) * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE/2,
    y: Math.floor(MAP_H/2) * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE/2,
    w: 10, h: 12,
    hp: CONFIG.PLAYER_BASE_HP,
    maxHp: CONFIG.PLAYER_BASE_HP,
    attack: CONFIG.PLAYER_BASE_ATTACK,
    level: 1,
    xp: 0,
    coins: 0,
    potions: CONFIG.STARTING_POTIONS,
    facing: {x:0,y:1},
    lastDamageAt: 0,
    lastAttackAt: 0,
  },
  npcs: [],
  enemies: [],
  projectiles: [],
  quest: {
    active:false, target:'Defeat 12 slimes', targetCount:12, progress:0, given:false, complete:false
  },
  gamePaused: false,
  gameOver: false,
  lastSave: null
};

// Helper: tile coordinate to world position center
function tileToWorld(tx,ty){ return {x: tx*CONFIG.TILE_SIZE + CONFIG.TILE_SIZE/2, y: ty*CONFIG.TILE_SIZE + CONFIG.TILE_SIZE/2}; }

/* ---- NPC (villager) ----
   One villager placed on the island near center.
*/
function spawnNPC(){
  // find a sand tile near center
  for(let r=0;r<200;r++){
    const tx = Math.floor(MAP_W/2) + randInt(-4,4);
    const ty = Math.floor(MAP_H/2) + randInt(-3,3);
    if(map[mapIndex(tx,ty)]!==TILE.WATER && map[mapIndex(tx,ty)]!==TILE.WALL){
      const pos = tileToWorld(tx,ty);
      state.npcs = [{id:'villager',x:pos.x,y:pos.y,w:10,h:12,dialogShown:false}];
      return;
    }
  }
}
spawnNPC();

/* ---- Enemies: slimes ----
   Slimes wander randomly, collide with player to deal damage,
   and drop XP/coins on death.
*/
function spawnSlimes(n){
  const slimes = [];
  for(let i=0;i<n;i++){
    let tries=0;
    while(tries<300){
      tries++;
      const tx = randInt(2,MAP_W-3);
      const ty = randInt(2,MAP_H-3);
      if(map[mapIndex(tx,ty)]===TILE.GRASS || map[mapIndex(tx,ty)]===TILE.SAND){
        slimes.push({
          id: 'slime'+Math.random().toString(36).slice(2,6),
          x: tx*CONFIG.TILE_SIZE + CONFIG.TILE_SIZE/2 + randInt(-4,4),
          y: ty*CONFIG.TILE_SIZE + CONFIG.TILE_SIZE/2 + randInt(-4,4),
          w:10,h:8,
          hp: 12,
          maxHp:12,
          speed: CONFIG.ENEMY_SPEED,
          dir: {x:0,y:0},
          changeAt: 0
        });
        break;
      }
    }
  }
  state.enemies = state.enemies.concat(slimes);
}
spawnSlimes(CONFIG.SLIME_COUNT);

/* =========================
   SAVE / LOAD using localStorage
   ========================= */
const SAVE_KEY = 'pixelquest_save_v1';
function saveGame(){
  const s = {
    player: {
      x: state.player.x, y: state.player.y, hp: state.player.hp, maxHp: state.player.maxHp,
      attack: state.player.attack, level: state.player.level, xp: state.player.xp, coins: state.player.coins, potions: state.player.potions
    },
    quest: state.quest,
    enemies: state.enemies.map(e=>({x:e.x,y:e.y,hp:e.hp, id:e.id})),
    map,
    timestamp: Date.now()
  };
  localStorage.setItem(SAVE_KEY, JSON.stringify(s));
  state.lastSave = new Date();
  beep(880,0.05,'square');
  alert('Game saved.');
}
function loadGame(){
  const raw = localStorage.getItem(SAVE_KEY);
  if(!raw) return false;
  try{
    const s = JSON.parse(raw);
    state.player.x = s.player.x; state.player.y = s.player.y;
    state.player.hp = s.player.hp; state.player.maxHp = s.player.maxHp;
    state.player.attack = s.player.attack; state.player.level = s.player.level; state.player.xp = s.player.xp;
    state.player.coins = s.player.coins; state.player.potions = s.player.potions;
    state.quest = s.quest || state.quest;
    if(s.enemies && s.enemies.length) state.enemies = s.enemies.map(e=>({...e,w:10,h:8,maxHp:e.hp,speed:CONFIG.ENEMY_SPEED,dir:{x:0,y:0},changeAt:0}));
    beep(660,0.05,'triangle');
    return true;
  }catch(e){
    console.error('Load failed',e);
    return false;
  }
}

/* =========================
   INPUT: joystick (touch), action button, keyboard
   ========================= */
const joystick = document.getElementById('joystick');
const thumb = document.getElementById('joyStickThumb');
const actionBtn = document.getElementById('actionBtn');
let input = {x:0,y:0,attack:false};

let joyActive = false;
let joyCenter = {x:0,y:0}, joyRadius = 40;

function toLocalPos(e,el){
  const r = el.getBoundingClientRect();
  const p = e.touches ? e.touches[0] : e;
  return {x: p.clientX - r.left, y: p.clientY - r.top};
}

function startJoy(e){
  e.preventDefault();
  joyActive = true;
  const r = joystick.getBoundingClientRect();
  joyCenter = {x:r.left + r.width/2, y:r.top + r.height/2};
  const p = e.touches ? e.touches[0] : e;
  updateJoyFromPoint({x:p.clientX,y:p.clientY});
}
function endJoy(){
  joyActive = false;
  input.x = 0; input.y = 0;
  thumb.style.transform = `translate(${(joyRadius-40)/2}px, ${(joyRadius-40)/2}px)`;
}
function updateJoyFromPoint(pt){
  const dx = pt.x - joyCenter.x;
  const dy = pt.y - joyCenter.y;
  const r = Math.max(joystick.clientWidth/2 - 12, 36);
  let vx = dx / r, vy = dy / r;
  const mag = Math.hypot(vx,vy);
  if(mag>1){ vx/=mag; vy/=mag; }
  input.x = vx; input.y = vy;
  // thumb visual
  const thumbX = vx * r/1.6;
  const thumbY = vy * r/1.6;
  thumb.style.transform = `translate(${thumbX + (joystick.clientWidth/2 - thumb.clientWidth/2)}px, ${thumbY + (joystick.clientHeight/2 - thumb.clientHeight/2)}px)`;
}

// attach pointer events
joystick.addEventListener('pointerdown', (e)=>{ joystick.setPointerCapture(e.pointerId); startJoy(e); });
joystick.addEventListener('pointermove', (e)=>{ if(joyActive) updateJoyFromPoint({x:e.clientX,y:e.clientY}); });
joystick.addEventListener('pointerup', (e)=>{ joystick.releasePointerCapture(e.pointerId); endJoy(); });
joystick.addEventListener('pointercancel', endJoy);

// action button
actionBtn.addEventListener('pointerdown', (e)=>{ e.preventDefault(); doAttackInteract(); });
// also support keyboard
window.addEventListener('keydown', (e)=>{
  if(e.key==='ArrowUp'){ input.y=-1; }
  if(e.key==='ArrowDown'){ input.y=1; }
  if(e.key==='ArrowLeft'){ input.x=-1; }
  if(e.key==='ArrowRight'){ input.x=1; }
  if(e.key===' ' || e.key==='Spacebar'){ doAttackInteract(); }
  if(e.key==='Escape'){ togglePause(); }
});
window.addEventListener('keyup', (e)=>{
  if(['ArrowUp','ArrowDown']){ if(e.key==='ArrowUp' || e.key==='ArrowDown') input.y=0;}
  if(['ArrowLeft','ArrowRight']){ if(e.key==='ArrowLeft' || e.key==='ArrowRight') input.x=0;}
});

/* ================
   INTERACTIONS
   ================ */
const dialogEl = document.getElementById('dialog');
function showDialog(text,ms=2500){
  dialogEl.style.display = 'block';
  document.getElementById('dialogText').textContent = text;
  clearTimeout(dialogEl._hideT);
  dialogEl._hideT = setTimeout(()=>dialogEl.style.display='none', ms);
}

// attack or interact function
function doAttackInteract(){
  const now = performance.now();
  // handle interact with NPC if nearby
  const player = state.player;
  const npc = state.npcs[0];
  if(npc && dist(player,npc) < 18){
    // show dialogue and give quest if not given
    if(!state.quest.given){
      state.quest.given = true;
      state.quest.active = true;
      showDialog('Villager: Please defeat 3 slimes and bring peace to the island!');
      beep(520,0.08,'sine');
      return;
    } else if(state.quest.active && !state.quest.complete){
      showDialog(`Villager: Progress ${state.quest.progress}/${state.quest.targetCount} slimes.`);
      return;
    } else if(state.quest.complete){
      showDialog('Villager: Thank you, hero! You have my gratitude.');
      return;
    }
  }
  // attack if cooldown finished
  if(now - player.lastAttackAt > CONFIG.ATTACK_COOLDOWN){
    player.lastAttackAt = now;
    // simple melee: radius in facing direction
    const attackRange = 18;
    const fx = player.facing.x===0 && player.facing.y===0 ? 0 : player.facing.x;
    const fy = player.facing.y===0 && player.facing.x===0 ? 1 : player.facing.y;
    // apply damage to any enemy in range
    let hit = false;
    state.enemies.forEach(e=>{
      const dx = e.x - player.x, dy = e.y - player.y;
      if(Math.hypot(dx - fx*attackRange, dy - fy*attackRange) < 18){
        e.hp -= player.attack;
        hit = true;
        // small hit effect
        spawnHitEffect(e.x,e.y);
        if(e.hp <= 0){
          // drop coins/xp
          state.player.coins += CONFIG.COIN_PER_SLIME;
          state.player.xp += CONFIG.XP_PER_SLIME;
          // handle quest progress
          if(state.quest.active && !state.quest.complete) {
            state.quest.progress++;
            if(state.quest.progress >= state.quest.targetCount){
              state.quest.complete = true; state.quest.active = false;
              showDialog('Quest complete! Return to the villager.');
            } else {
              showDialog(`Quest progress: ${state.quest.progress}/${state.quest.targetCount}`);
            }
          }
        }
      }
    });
    // remove dead enemies and spawn little coin/puff
    const dead = state.enemies.filter(e=>e.hp<=0);
    if(dead.length){
      dead.forEach(d=>{
        spawnKillEffect(d.x,d.y);
      });
      state.enemies = state.enemies.filter(e=>e.hp>0);
      // play kill beep
      beep(880,0.06,'square');
    } else {
      if(hit) beep(720,0.04,'sawtooth'); else beep(320,0.03,'sine');
    }
    // level up check
    checkLevelUp();
  }
}

/* =========================
   DAMAGE / EFFECTS
   ========================= */
let effects = []; // small visual effects (particles)

function spawnHitEffect(x,y){
  for(let i=0;i<6;i++){
    effects.push({x,y,dx:(Math.random()-0.5)*50,dy:(Math.random()-0.5)*50,life:300,age:0});
  }
}
function spawnKillEffect(x,y){
  for(let i=0;i<16;i++){
    effects.push({x,y,dx:(Math.random()-0.5)*80,dy:(Math.random()-0.5)*80,life:700,age:0,fade:true});
  }
}

/* =========================
   PLAYER / ENEMY LOGIC
   ========================= */
function updateEntities(dt){
  const p = state.player;
  // movement
  const moveX = input.x, moveY = input.y;
  if(moveX !== 0 || moveY !== 0){
    // normalize diagonal
    let mvx=moveX, mvy=moveY;
    if(mvx!==0 && mvy!==0){ const m=1/Math.hypot(mvx,mvy); mvx*=m; mvy*=m;}
    p.x += mvx * CONFIG.PLAYER_SPEED * (dt/1000);
    p.y += mvy * CONFIG.PLAYER_SPEED * (dt/1000);
    p.facing.x = mvx; p.facing.y = mvy;
  }
  // clamp to map bounds
  p.x = clamp(p.x, 8, MAP_W*CONFIG.TILE_SIZE - 8);
  p.y = clamp(p.y, 8, MAP_H*CONFIG.TILE_SIZE - 8);

  // simple collision with blocked tiles (walls)
  handleTileCollisions(p);

  // update enemies
  state.enemies.forEach(e=>{
    if(performance.now()>e.changeAt){
      // pick a random direction for a while
      const a = Math.random()*Math.PI*2;
      e.dir = {x: Math.cos(a), y: Math.sin(a)};
      e.changeAt = performance.now() + randInt(500,2200);
    }
    e.x += e.dir.x * e.speed * (dt/1000);
    e.y += e.dir.y * e.speed * (dt/1000);
    // keep inside island bounds and avoid water/walls
    if(e.x < CONFIG.TILE_SIZE || e.y < CONFIG.TILE_SIZE || e.x > MAP_W*CONFIG.TILE_SIZE - CONFIG.TILE_SIZE || e.y > MAP_H*CONFIG.TILE_SIZE - CONFIG.TILE_SIZE){
      e.dir.x *= -1; e.dir.y *= -1;
    }
    // tile collisions for enemies
    handleTileCollisions(e);
    // contact with player
    if(Math.hypot(e.x - p.x, e.y - p.y) < 12){
      const now = performance.now();
      if(now - p.lastDamageAt > CONFIG.DAMAGE_COOLDOWN){
        p.lastDamageAt = now;
        p.hp -= CONFIG.ENEMY_CONTACT_DAMAGE;
        spawnHitEffect(p.x,p.y);
        beep(160,0.08,'sawtooth');
        if(p.hp <= 0) doGameOver();
      }
    }
  });

  // update effects
  effects.forEach(f=>{
    f.age += dt;
    f.x += f.dx * (dt/1000);
    f.y += f.dy * (dt/1000);
    f.dx *= 0.98; f.dy *= 0.98;
  });
  effects = effects.filter(f=>f.age < f.life);

  // respawn basic slimes if too few
  if(state.enemies.length < Math.max(1, CONFIG.SLIME_COUNT - 1) && !state.gameOver){
    spawnSlimes(1);
  }
}

/* Tile collision helper: prevents entity center from entering blocked tiles */
function handleTileCollisions(ent){
  const tx = Math.floor(ent.x / CONFIG.TILE_SIZE);
  const ty = Math.floor(ent.y / CONFIG.TILE_SIZE);
  // check surrounding tiles
  for(let oy=-1;oy<=1;oy++){
    for(let ox=-1;ox<=1;ox++){
      const nx = tx+ox, ny = ty+oy;
      if(nx<0||ny<0||nx>=MAP_W||ny>=MAP_H) continue;
      const t = map[mapIndex(nx,ny)];
      if(t===TILE.WATER || t===TILE.WALL){
        // tile bounds
        const left = nx*CONFIG.TILE_SIZE;
        const right = left + CONFIG.TILE_SIZE;
        const top = ny*CONFIG.TILE_SIZE;
        const bottom = top + CONFIG.TILE_SIZE;
        // simple push-out if inside
        if(ent.x > left && ent.x < right && ent.y > top && ent.y < bottom){
          // push to nearest edge
          const cx = (left+right)/2, cy=(top+bottom)/2;
          const dx = ent.x - cx, dy = ent.y - cy;
          if(Math.abs(dx) > Math.abs(dy)){
            ent.x = dx > 0 ? right + 1 : left - 1;
          } else {
            ent.y = dy > 0 ? bottom + 1 : top - 1;
          }
        }
      }
    }
  }
}

/* Level up: simple XP scaling
   XP to next level = CONFIG.XP_BASE * level
*/
function xpToNext(level){
  return CONFIG.XP_BASE * level;
}
function checkLevelUp(){
  const p = state.player;
  while(p.xp >= xpToNext(p.level)){
    p.xp -= xpToNext(p.level);
    p.level++;
    p.maxHp += 4;
    p.attack += 2;
    p.hp = p.maxHp;
    showDialog('LEVEL UP! Lvl '+p.level, 1800);
    beep(1200,0.16,'triangle');
  }
}

/* =========================
   GAME OVER / RESTART
   ========================= */
function doGameOver(){
  state.gameOver = true;
  document.getElementById('gameOverMenu').style.display = 'flex';
  document.getElementById('gameOverMsg').textContent = `You reached level ${state.player.level}. Coins: ${state.player.coins}`;
  beep(120,0.8,'sine');
}
document.getElementById('respawnBtn').addEventListener('click', ()=>{
  state.gameOver=false;
  // respawn at center with some HP, keep coins
  state.player.x = Math.floor(MAP_W/2) * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE/2;
  state.player.y = Math.floor(MAP_H/2) * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE/2;
  state.player.hp = Math.max(4, Math.floor(state.player.maxHp/2));
  document.getElementById('gameOverMenu').style.display='none';
});
document.getElementById('goToMenuBtn').addEventListener('click', ()=>{
  document.getElementById('gameOverMenu').style.display='none';
  state.gameOver=false;
  document.getElementById('startMenu').style.display='flex';
});

/* =========================
   UI buttons (start, pause, save)
   ========================= */
document.getElementById('startBtn').addEventListener('click', ()=>{ startNewGame(); });
document.getElementById('loadBtn').addEventListener('click', ()=>{
  const ok = loadGame();
  if(ok){
    document.getElementById('startMenu').style.display='none';
    beep(720,0.06,'sine');
  } else alert('No save found.');
});
document.getElementById('creditsBtn').addEventListener('click', ()=>{
  alert('Pixel Quest: Island of Shadows\nSingle file demo ‚Ä¢ Procedural island\n(Use arrow keys or joystick. A = attack/interact)\nCreated with vanilla JS & canvas.');
});
document.getElementById('resumeBtn').addEventListener('click', ()=>{ togglePause(false); });
document.getElementById('saveBtn').addEventListener('click', saveGame);
document.getElementById('restartBtn').addEventListener('click', ()=>{
  if(confirm('Restart the game?')) startNewGame();
});

function togglePause(force){
  state.gamePaused = (typeof force==='boolean')?!force:!state.gamePaused;
  document.getElementById('pauseMenu').style.display = state.gamePaused ? 'flex' : 'none';
  if(state.gamePaused) beep(220,0.06,'sine'); else beep(660,0.04,'sine');
}
// open pause with two-finger tap? (keyboard uses Escape too)
canvas.addEventListener('contextmenu', (e)=>{ e.preventDefault(); togglePause(); });

/* Start new game */
function startNewGame(){
  // reset state to defaults
  generateMap();
  state.player = {
    x: Math.floor(MAP_W/2) * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE/2,
    y: Math.floor(MAP_H/2) * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE/2,
    w:10,h:12, hp:CONFIG.PLAYER_BASE_HP, maxHp:CONFIG.PLAYER_BASE_HP,
    attack:CONFIG.PLAYER_BASE_ATTACK, level:1, xp:0, coins:0, potions:CONFIG.STARTING_POTIONS,
    facing:{x:0,y:1}, lastDamageAt:0, lastAttackAt:0
  };
  spawnNPC();
  state.enemies = [];
  spawnSlimes(CONFIG.SLIME_COUNT);
  state.quest = {active:false,target:'Defeat 3 slimes',targetCount:3,progress:0,given:false,complete:false};
  state.gamePaused=false; state.gameOver=false;
  document.getElementById('startMenu').style.display='none';
  document.getElementById('pauseMenu').style.display='none';
  document.getElementById('gameOverMenu').style.display='none';
  beep(880,0.06,'square');
}

/* Potion usage */
document.getElementById('potionBtn').addEventListener('click', ()=>{
  if(state.player.potions > 0 && state.player.hp < state.player.maxHp){
    state.player.potions--;
    state.player.hp = Math.min(state.player.maxHp, state.player.hp + CONFIG.POTION_HEAL);
    showDialog('You used a potion.');
    beep(460,0.06,'triangle');
  } else {
    showDialog('No potion or HP is full.');
    beep(240,0.05,'sine');
  }
});

/* =========================
   RENDERING: pixel-art style
   ========================= */
function draw(){
  // clear (solid background)
  ctx.fillStyle = '#071520';
  ctx.fillRect(0,0,W,H);

  // compute camera: center on player but keep within map bounds
  const camW = W, camH = H;
  let camX = Math.floor(state.player.x - camW/2);
  let camY = Math.floor(state.player.y - camH/2);
  camX = clamp(camX, 0, MAP_W*CONFIG.TILE_SIZE - camW);
  camY = clamp(camY, 0, MAP_H*CONFIG.TILE_SIZE - camH);

  // draw tiles
  for(let y=0;y<MAP_H;y++){
    for(let x=0;x<MAP_W;x++){
      const t = map[mapIndex(x,y)];
      const sx = x*CONFIG.TILE_SIZE - camX;
      const sy = y*CONFIG.TILE_SIZE - camY;
      if(sx+CONFIG.TILE_SIZE < 0 || sy+CONFIG.TILE_SIZE < 0 || sx > W || sy > H) continue;
      // choose colors for tiles (pixel-ish)
      if(t===TILE.WATER){
        // animated water using time
        const tphase = Math.floor(performance.now()/500) % 4;
        ctx.fillStyle = ['#013c52','#01445c','#00526a','#013c52'][tphase];
        ctx.fillRect(sx,sy,CONFIG.TILE_SIZE,CONFIG.TILE_SIZE);
      } else if(t===TILE.GRASS){
        ctx.fillStyle = '#0b7a3a';
        ctx.fillRect(sx,sy,CONFIG.TILE_SIZE,CONFIG.TILE_SIZE);
        // add simple grass pixels
        ctx.fillStyle = '#0f9a52';
        for(let i=0;i<2;i++){
          ctx.fillRect(sx + (i*6)+2, sy + (i*4)+2, 1,1);
        }
      } else if(t===TILE.SAND){
        ctx.fillStyle = '#c9ad7d';
        ctx.fillRect(sx,sy,CONFIG.TILE_SIZE,CONFIG.TILE_SIZE);
      } else if(t===TILE.WALL){
        ctx.fillStyle = '#4a4a4a';
        ctx.fillRect(sx,sy,CONFIG.TILE_SIZE,CONFIG.TILE_SIZE);
        // rock highlight
        ctx.fillStyle = '#6b6b6b';
        ctx.fillRect(sx+2,sy+2,4,4);
      }
    }
  }

  // draw NPCs
  state.npcs.forEach(n=>{
    const sx = n.x - camX, sy = n.y - camY;
    drawVillager(sx,sy);
  });

  // draw enemies
  state.enemies.forEach(e=>{
    const sx = e.x - camX, sy = e.y - camY;
    drawSlime(e,sx,sy);
  });

  // draw player
  drawPlayer(state.player.x - camX, state.player.y - camY, state.player);

  // draw effects (particles)
  effects.forEach(f=>{
    const a = 1 - f.age/f.life;
    ctx.fillStyle = `rgba(255,220,120,${a})`;
    ctx.fillRect(f.x - camX, f.y - camY, 2,2);
  });

  // HUD draw overlay elements like quest marker above NPC
  if(state.npcs[0]){
    const n = state.npcs[0], sx = n.x - camX, sy = n.y - camY;
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    ctx.fillRect(sx-6, sy-18, 12, 6);
  }
  // draw player stats HUD (we update DOM separately)
}

/* helper: simple pixel player */
function drawPlayer(sx,sy,p){
  // body shadow
  ctx.fillStyle = '#002020';
  ctx.fillRect(sx-5, sy-6+6, 12, 6);
  // body
  ctx.fillStyle = '#ffd38a';
  ctx.fillRect(sx-5,sy-6,10,10);
  // head
  ctx.fillStyle = '#ffb86b';
  ctx.fillRect(sx-4,sy-14,8,8);
  // eyes
  ctx.fillStyle = '#000';
  ctx.fillRect(sx-2,sy-12,1,1); ctx.fillRect(sx+1,sy-12,1,1);
  // sword/attack indicator in facing dir
  const now = performance.now();
  if(now - p.lastAttackAt < 140){
    // draw a slash in facing direction
    const fx = p.facing.x || 0, fy = p.facing.y || 1;
    ctx.fillStyle = 'rgba(255,180,80,0.95)';
    ctx.fillRect(sx + fx*12 - 2, sy + fy*12 - 2, 6, 4);
  }
}

/* helper: slime sprite */
function drawSlime(e,sx,sy){
  // body blob with wobble
  const wob = Math.sin(performance.now()/200 + e.x) * 1.5;
  ctx.fillStyle = '#6de06b';
  ctx.fillRect(sx-6, sy-6 + wob, 12, 8);
  ctx.fillStyle = '#48b24a';
  ctx.fillRect(sx-4, sy-8 + wob, 2,2);
  ctx.fillRect(sx+2, sy-8 + wob, 2,2);
  // HP bar
  ctx.fillStyle = 'rgba(0,0,0,0.6)';
  ctx.fillRect(sx-8,sy-12,16,3);
  ctx.fillStyle = '#d44';
  ctx.fillRect(sx-8, sy-12, 16 * (e.hp / e.maxHp), 3);
}

/* helper: villager */
function drawVillager(sx,sy){
  ctx.fillStyle = '#3a3a3a';
  ctx.fillRect(sx-5, sy-8, 10,12); // body
  ctx.fillStyle = '#ffd';
  ctx.fillRect(sx-4, sy-12, 8,6); // head
  ctx.fillStyle = '#000';
  ctx.fillRect(sx-2, sy-10,1,1); ctx.fillRect(sx+1, sy-10,1,1);
}

/* =========================
   DOM HUD updates
   ========================= */
function updateHUD(){
  document.getElementById('hpText').textContent = `${state.player.hp}/${state.player.maxHp}`;
  document.getElementById('xpText').textContent = `${state.player.xp}/${xpToNext(state.player.level)}`;
  document.getElementById('lvlText').textContent = `${state.player.level}`;
  document.getElementById('coinText').textContent = `${state.player.coins}`;
  document.getElementById('potionCount').textContent = `${state.player.potions}`;
  // update quest summary in pause menu
  document.getElementById('questSummary').textContent = `Quest: ${state.quest.given ? (state.quest.complete ? 'Completed' : `${state.quest.progress}/${state.quest.targetCount}`) : 'Not given'}`;
}

/* =========================
   MAIN LOOP
   ========================= */
let last = performance.now();
let acc = 0;
function mainLoop(ts){
  const now = performance.now();
  let dt = now - last;
  last = now;
  // cap dt to avoid huge jumps when tabbed out
  if(dt > 80) dt = 80;

  if(!state.gamePaused && !state.gameOver){
    updateEntities(dt);
  }
  draw();
  updateHUD();
  requestAnimationFrame(mainLoop);
}
requestAnimationFrame(mainLoop);

/* =========================
   Debug / helper: click to interact with NPC / spawn coin
   ========================= */
canvas.addEventListener('pointerdown',(e)=>{
  // translate to world coords
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  const cx = (e.clientX - rect.left) * scaleX;
  const cy = (e.clientY - rect.top) * scaleY;
  // convert to world coords
  // compute camera as in draw
  let camX = Math.floor(state.player.x - W/2);
  let camY = Math.floor(state.player.y - H/2);
  camX = clamp(camX, 0, MAP_W*CONFIG.TILE_SIZE - W);
  camY = clamp(camY, 0, MAP_H*CONFIG.TILE_SIZE - H);
  const wx = camX + cx, wy = camY + cy;
  // if clicked near NPC, show dialog
  const npc = state.npcs[0];
  if(npc && Math.hypot(npc.x - wx, npc.y - wy) < 18){
    doAttackInteract();
  }
});

/* =========================
   Initial UI state
   ========================= */
document.getElementById('startMenu').style.display='flex';
document.getElementById('pauseMenu').style.display='none';

/* =========================
   Helpful comments for modders:
   - Change CONFIG.* values to tune gameplay (XP, damage, tile size).
   - Map generation is in generateMap(); replace with a static map array for handcrafted levels.
   - Sprites are drawn procedurally in drawPlayer/drawSlime/drawVillager for pixel look.
   - To increase difficulty, raise CONFIG.SLIME_COUNT or reduce player attack / increase enemy speed.
   - To add more enemy types, follow the structure in spawnSlimes() and update draw/enemy logic.
   - Save format is simple JSON in localStorage under SAVE_KEY.
   ========================= */

</script>
</body>
</html>
